import {Helmet} from "react-helmet"
import {Links,Meta,Scripts,ScrollRestoration} from "react-router"
import reflexGlobalStyles from "$/styles/__reflex_global_styles.css?url"
import {jsx} from "@emotion/react"
import {Fragment,useEffect} from "react"

export function Layout({children}) {
  return (
    jsx("html",{lang:"en",suppressHydrationWarning:true},jsx("head",{},jsx("script",{},"\n// Only run in browser environment, not during SSR\nif (typeof document !== 'undefined') {\n    try {\n        const theme = localStorage.getItem(\"theme\") || \"system\";\n        const systemPreference = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n        const resolvedTheme = theme === \"system\" ? systemPreference : theme;\n\n        // Apply theme immediately - blocks until complete\n        // Use classList to avoid overwriting other classes\n        document.documentElement.classList.remove(\"light\", \"dark\");\n        document.documentElement.classList.add(resolvedTheme);\n        document.documentElement.style.colorScheme = resolvedTheme;\n\n    } catch (e) {\n        // Fallback to system preference on any error (resolve \"system\" to actual theme)\n        const fallbackTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n        document.documentElement.classList.remove(\"light\", \"dark\");\n        document.documentElement.classList.add(fallbackTheme);\n        document.documentElement.style.colorScheme = fallbackTheme;\n    }\n}\n"),jsx(Helmet,{},jsx("script",{src:"https://maps.googleapis.com/maps/api/js?key=AIzaSyDK4hwtBpHc6gnSzvpO9rU6hMSPuQVpoCA&libraries=places&callback=Function.prototype"},)),jsx(Helmet,{},jsx("script",{},"\nfunction initLocationAutocomplete() {\n    if (typeof google === 'undefined' || !google.maps || !google.maps.places) {\n        setTimeout(initLocationAutocomplete, 200);\n        return;\n    }\n    \n    const input = document.getElementById('location-autocomplete-input');\n    const suggestionsDiv = document.getElementById('location-suggestions');\n    \n    if (!input || !suggestionsDiv) {\n        setTimeout(initLocationAutocomplete, 200);\n        return;\n    }\n    \n    let sessionToken = new google.maps.places.AutocompleteSessionToken();\n    const placesService = new google.maps.places.PlacesService(document.createElement('div'));\n    let debounceTimer;\n    \n    function searchLocation(query) {\n        if (query.length < 3) {\n            suggestionsDiv.classList.add('hidden');\n            return;\n        }\n        \n        const autocompleteService = new google.maps.places.AutocompleteService();\n        \n        autocompleteService.getPlacePredictions({\n            input: query,\n            sessionToken: sessionToken,\n            types: ['geocode', 'establishment']\n        }, (predictions, status) => {\n            if (status === google.maps.places.PlacesServiceStatus.OK && predictions) {\n                displaySuggestions(predictions);\n            } else if (status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {\n                suggestionsDiv.innerHTML = '<div class=\"p-3 text-slate-400 text-sm\">No locations found</div>';\n                suggestionsDiv.classList.remove('hidden');\n            } else {\n                suggestionsDiv.classList.add('hidden');\n            }\n        });\n    }\n    \n    function displaySuggestions(predictions) {\n        suggestionsDiv.innerHTML = '';\n        suggestionsDiv.classList.remove('hidden');\n        \n        predictions.slice(0, 5).forEach(prediction => {\n            const div = document.createElement('div');\n            div.className = 'p-3 hover:bg-slate-800 cursor-pointer border-b border-slate-700 last:border-0 transition-colors';\n            \n            const mainText = prediction.structured_formatting.main_text;\n            const secondaryText = prediction.structured_formatting.secondary_text || '';\n            \n            div.innerHTML = `\n                <div class=\"flex items-start\">\n                    <svg class=\"h-4 w-4 text-cyan-400 mr-2 mt-0.5 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z\"></path>\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 11a3 3 0 11-6 0 3 3 0 016 0z\"></path>\n                    </svg>\n                    <div class=\"flex-1\">\n                        <div class=\"text-sm text-slate-200 font-medium\">${mainText}</div>\n                        ${secondaryText ? `<div class=\"text-xs text-slate-400 mt-0.5\">${secondaryText}</div>` : ''}\n                    </div>\n                </div>\n            `;\n            \n            div.onclick = () => selectLocation(prediction);\n            suggestionsDiv.appendChild(div);\n        });\n    }\n    \n    function selectLocation(prediction) {\n        suggestionsDiv.classList.add('hidden');\n        \n        placesService.getDetails({\n            placeId: prediction.place_id,\n            fields: ['geometry', 'formatted_address'],\n            sessionToken: sessionToken\n        }, (place, status) => {\n            if (status === google.maps.places.PlacesServiceStatus.OK && place.geometry) {\n                const lat = place.geometry.location.lat();\n                const lng = place.geometry.location.lng();\n                const address = place.formatted_address;\n                \n                // Store coordinates in data attributes (survives re-renders)\n                input.setAttribute('data-lat', lat);\n                input.setAttribute('data-lng', lng);\n                \n                // IMPORTANT: Update the input value AND trigger Reflex state update\n                input.value = address;\n                \n                // Trigger events to ensure state is updated (avoid input to prevent re-search)\n                input.dispatchEvent(new Event('change', { bubbles: true }));\n                input.dispatchEvent(new Event('blur', { bubbles: true }));\n\n                // Update hidden reactive inputs so Reflex state captures coordinates\n                const latInput = document.getElementById('hidden-lat');\n                const lngInput = document.getElementById('hidden-lng');\n                if (latInput && lngInput) {\n                    latInput.value = lat;\n                    lngInput.value = lng;\n                    latInput.dispatchEvent(new Event('change', { bubbles: true }));\n                    lngInput.dispatchEvent(new Event('change', { bubbles: true }));\n                }\n                \n                // Also store globally as backup\n                window.lastSelectedLocation = { lat, lng, address };\n                \n                console.log('\u2705 Location selected and saved:', { address, lat, lng });\n\n                // Suppress autocomplete search briefly to avoid dropdown reappearing after re-render\n                window.locationAutocompleteSuppressUntil = Date.now() + 1500;\n                \n                sessionToken = new google.maps.places.AutocompleteSessionToken();\n            }\n        });\n    }\n    \n    input.addEventListener('input', (e) => {\n        if (window.locationAutocompleteSuppressUntil && Date.now() < window.locationAutocompleteSuppressUntil) {\n            suggestionsDiv.classList.add('hidden');\n            return;\n        }\n        clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(() => searchLocation(e.target.value.trim()), 800);\n    });\n    \n    document.addEventListener('click', (e) => {\n        if (!input.contains(e.target) && !suggestionsDiv.contains(e.target)) {\n            suggestionsDiv.classList.add('hidden');\n        }\n    });\n}\n\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initLocationAutocomplete);\n} else {\n    setTimeout(initLocationAutocomplete, 500);\n}\n\n// Clear location data on page load to prevent stale data\nwindow.addEventListener('load', function() {\n    const input = document.getElementById('location-autocomplete-input');\n    if (input) {\n        input.removeAttribute('data-lat');\n        input.removeAttribute('data-lng');\n    }\n});\n\n// Helper function to extract coordinates before form submission\nwindow.extractLocationCoordinates = function() {\n    const input = document.getElementById('location-autocomplete-input');\n    if (input) {\n        const lat = parseFloat(input.getAttribute('data-lat')) || 0.0;\n        const lng = parseFloat(input.getAttribute('data-lng')) || 0.0;\n        console.log('\ud83d\udccd Extracted coordinates:', { lat, lng, address: input.value });\n        return { lat, lng, address: input.value };\n    }\n    return { lat: 0.0, lng: 0.0, address: '' };\n};\n\n// Restore location data after page re-renders (e.g., after image upload)\nconst observer = new MutationObserver(function() {\n    const input = document.getElementById('location-autocomplete-input');\n    const latInput = document.getElementById('hidden-lat');\n    const lngInput = document.getElementById('hidden-lng');\n    if (input && window.lastSelectedLocation) {\n        // Restore data attributes and input value\n        if (!input.getAttribute('data-lat') && window.lastSelectedLocation.lat) {\n            input.setAttribute('data-lat', window.lastSelectedLocation.lat);\n            input.setAttribute('data-lng', window.lastSelectedLocation.lng);\n        }\n        if (window.lastSelectedLocation.address && input.value !== window.lastSelectedLocation.address) {\n            input.value = window.lastSelectedLocation.address;\n            // Trigger state update without re-search\n            input.dispatchEvent(new Event('change', { bubbles: true }));\n            // Hide suggestions if they were left open\n            suggestionsDiv.classList.add('hidden');\n        }\n        // Restore hidden inputs and trigger change for Reflex state\n        if (latInput && lngInput && window.lastSelectedLocation.lat) {\n            latInput.value = window.lastSelectedLocation.lat;\n            lngInput.value = window.lastSelectedLocation.lng;\n            latInput.dispatchEvent(new Event('change', { bubbles: true }));\n            lngInput.dispatchEvent(new Event('change', { bubbles: true }));\n        }\n    }\n});\n\n// Watch for DOM changes\nif (document.body) {\n    observer.observe(document.body, { childList: true, subtree: true });\n}\n        ")),jsx("meta",{charSet:"utf-8"},),jsx("meta",{content:"width=device-width, initial-scale=1",name:"viewport"},),jsx(Meta,{},),jsx("link",{href:reflexGlobalStyles,rel:"stylesheet",type:"text/css"},),jsx(Links,{},)),jsx("body",{},children,jsx(ScrollRestoration,{},),jsx(Scripts,{},)))
  )
}